module BosqueCollections

open List

val lemma_length_append : x : list 'a -> y : list 'a -> Lemma
  (requires True)
  (ensures lengthList x + lengthList y = lengthList (appendList x y)) [SMTPat (appendList x y)]
let rec lemma_length_append x y = match x with
| LNil -> ()
| LCons hd tl -> lemma_length_append tl y

val lemma_length_map : f : ('a -> 'b) -> x : list 'a -> Lemma 
  (requires True) 
  (ensures lengthList x = lengthList (mapList f x)) [SMTPat (mapList f x)]
let rec lemma_length_map f x = match x with 
| LNil -> ()
| LCons hd tl -> lemma_length_map f tl

val lemma_length_filter : p : ('a -> bool) -> x : list 'a -> Lemma
  (requires True) 
  (ensures lengthList x >= lengthList (filterList p x)) [SMTPat (filterList p x)]
let rec lemma_length_filter p x = match x with
| LNil -> ()
| LCons hd tl -> lemma_length_filter p tl

val filter_append : p : ('a -> bool) -> x : list 'a -> y : list 'a -> Lemma 
  (requires True) 
  (ensures (appendList (filterList p x) (filterList p y)) == (filterList p (appendList x y))) [SMTPat (filterList p (appendList x y))]
let rec filter_append p x y = match x with 
| LNil -> ()
| LCons hd tl ->  filter_append p tl y 


type vector (a: Type) : nat -> Type =
| VNil : vector a 0
| VCons : n:nat -> hd:a -> tl:vector a n ->  vector a (n+1)

type matrix (a : Type) (m : nat) (n : nat) : Type = vector (vector a m) n

val position : #n:nat{n>0} -> #a:Type -> vector a n -> position:nat{position<n} -> Tot a 
let rec position #n #a xs i = match xs with 
| VCons _ hd tl -> if (i = 0) then hd else position tl (i-1)

val vec : n:nat -> (#a:Type) -> x : a -> vector a n
let rec vec n #a x = match n with 
| 0 -> VNil 
| _ -> VCons (n-1) x (vec (n - 1) x)

val infx : n:nat -> (#a:Type) -> (#b:Type) -> vector (a -> b) n -> vector a n -> vector b n
let rec infx n #a #b fs xs = match fs with 
| VNil -> VNil
| VCons n f fs' -> (match xs with
                  | VCons n x xs' ->  VCons n (f x) (infx n fs' xs')
                  )

val transpose' : #a:Type -> m:nat -> n:nat -> matrix a m n -> vector (vector (vector a m) n) m
let transpose' #a m n xss = vec m xss

val f : #a:Type -> m:nat -> n:nat -> vector (vector (vector a m) n) m -> vector (vector a n) m
let f #a m n xss = vec n (match xss with 
                         | VNil -> VNil 
                         | VCons n' hd tl -> (match hd with 
                                            | VNil -> VNil
                                            | VCons n'' hd'' tl'' -> hd''
                                            )
                         )

val transpose : #a:Type -> m:nat -> n:nat -> matrix a m n -> matrix a n m
let transpose #a m n xss = infx m (vec m (fun (x : vector (vector (vector a m) n) m) -> (match x with | VNil -> VNil | VCons n hd tl -> hd))) (vec m xss)
