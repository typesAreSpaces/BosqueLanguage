5a6,7
> (* Dynamic: depends on the 
>    entities created by user *) 
9c11
< | BInt : int -> bosqueTerm
---
> | BInt : int -> bosqueTerm 
29a32,43
> // | BnSMain__PlayerMark : mark : bosqueTerm{bTypedStringType_BAnyType = (getType mark)} -> 
> // nSMain__PlayerMark
> // | BnSMain__Artist : id : bosqueTerm{BIntType = (getType id)} -> 
> // isGood : bosqueTerm{BBoolType = (getType isGood)} -> 
> // lastName : bosqueTerm{bTypedStringType_BAnyType = (getType lastName)} -> 
> // name : bosqueTerm{bTypedStringType_BAnyType = (getType name)} -> 
> // player : nSMain__PlayerMark -> 
> // nSMain__Artist
> // | BnSMain__Musician : artist : nSMain__Artist -> 
> // instrument : bosqueTerm{bTypedStringType_BAnyType = (getType instrument)} -> 
> // nSMain__Musician
> 
114c128
< and assertions (in the z3 smt solver) *)
---
>    and assertions (in the z3 smt solver) *)
132,137c146,151
<     -> (x:sequence bosqueTerm n) 
<       -> sequence bosqueTerm n
<       -> Tot (z:bosqueTerm{isBool z}) (decreases x)
< val op_eqTerm : x:bosqueTerm
<       -> bosqueTerm
<       -> Tot (z:bosqueTerm{isBool z})  (decreases x)
---
>   -> (x:sequence bosqueTerm n) 
>   -> sequence bosqueTerm n 
>   -> Tot (z:bosqueTerm{isBool z}) (decreases x)
> val op_eqTerm : x:bosqueTerm 
>   -> bosqueTerm 
>   -> Tot (z:bosqueTerm{isBool z})  (decreases x)
145c159
<                                        else op_eqTerm_aux n1 seq1 seq2
---
>                                    else op_eqTerm_aux n1 seq1 seq2
152,154c166,168
<           | SNil -> BBool true
<           | _ -> BBool (false)
<           )
---
>          | SNil -> BBool true
>          | _ -> BBool (false)
>          )
156,168c170,182
<                     | SNil -> BBool (false)
<                     | SCons y1 m' ys1 -> (match (op_eqTerm x1 y1) with
<                                          | BBool b1 -> (match (op_eqTerm_aux m xs1 ys1) with
<                                                        | BBool b2 -> BBool ((m = m') && b1 && b2)
<                                                        | _ -> BBool (false)
<                                                        )
<                                          | _ -> BBool (false)
<                                          )
<                     )
< 
< val op_notEqTerm : x:bosqueTerm
<       -> bosqueTerm
<       -> Tot (z:bosqueTerm{isBool z})  (decreases x)
---
>                    | SNil -> BBool (false)
>                    | SCons y1 m' ys1 -> (match (op_eqTerm x1 y1) with
>                                        | BBool b1 -> (match (op_eqTerm_aux m xs1 ys1) with
>                                                     | BBool b2 -> BBool ((m = m') && b1 && b2)
>                                                     | _ -> BBool (false)
>                                                     )
>                                        | _ -> BBool (false) 
>                                        )
>                    )
> 
> val op_notEqTerm : x:bosqueTerm 
>   -> bosqueTerm 
>   -> Tot (z:bosqueTerm{isBool z})  (decreases x)
172c186
< val op_not : x:bosqueTerm{isBool x} -> Tot (z:bosqueTerm{isBool z})
---
> val op_not : x:bosqueTerm{isBool x} -> Tot (z:bosqueTerm{isBool z}) 
174c188
< | BBool x1 -> BBool (not x1)
---
> | BBool x1 -> BBool (not x1) 
176c190
< val op_and : x:bosqueTerm{isBool x} -> y:bosqueTerm{isBool y} -> Tot (z:bosqueTerm{isBool z})
---
> val op_and : x:bosqueTerm{isBool x} -> y:bosqueTerm{isBool y} -> Tot (z:bosqueTerm{isBool z}) 
178c192
< | BBool x1, BBool y1 -> BBool (x1 && y1)
---
> | BBool x1, BBool y1 -> BBool (x1 && y1) 
180c194
< val op_or : x:bosqueTerm{isBool x} -> y:bosqueTerm{isBool y} -> Tot (z:bosqueTerm{isBool z})
---
> val op_or : x:bosqueTerm{isBool x} -> y:bosqueTerm{isBool y} -> Tot (z:bosqueTerm{isBool z}) 
182c196
< | BBool x1, BBool y1 -> BBool (x1 || y1)
---
> | BBool x1, BBool y1 -> BBool (x1 || y1) 
187c201
< | BInt x1, BInt y1 -> BInt (op_Multiply x1 y1)
---
> | BInt x1, BInt y1 -> BInt (op_Multiply x1 y1) 
204c218
< | BInt x1 -> BInt (-x1)
---
> | BInt x1 -> BInt (-x1)  
216c230
< val op_greaterOrEq : x:bosqueTerm{isInt x} -> y:bosqueTerm{isInt y} -> Tot (z:bosqueTerm{isBool z})
---
> val op_greaterOrEq : x:bosqueTerm{isInt x} -> y:bosqueTerm{isInt y} -> Tot (z:bosqueTerm{isBool z}) 
238,242c252,256
<       if (index < 0 || dimension <> dimension'') then BErrorType else
<       if (index >= dimension) then BNoneType else
<       if index = 0 then getType x
<       else nthTupleType (index-1) dimension' (BTuple dimension' xs)
< | _ -> BErrorType
---
>   if (index < 0 || dimension <> dimension'') then BErrorType else
>   if (index >= dimension) then BNoneType else
>   if index = 0 then getType x
>   else nthTupleType (index-1) dimension' (BTuple dimension' xs)
> | _ -> BErrorType 
249,252c263,266
<       if (index < 0 || dimension <> dimension'') then BError else
<       if (index >= dimension) then BNone else
<       if index = 0 then x'
<       else nthTuple (index-1) dimension' (BTuple dimension' xs')
---
>   if (index < 0 || dimension <> dimension'') then BError else
>   if (index >= dimension) then BNone else
>   if index = 0 then x'
>   else nthTuple (index-1) dimension' (BTuple dimension' xs')
255,265c269,279
<     // TODO: Implement the Record Projector
<     // (* Record projector *)
<     // val nthRecord : index:int -> dimension:nat -> bosqueTerm -> Tot bosqueTerm
<     // let rec nthRecord index dimension y = match y with
<     // | BTuple 0 SNil -> if (index < 0 || dimension <> 0) then BError else BNone
<     // | BTuple dimension'' (SCons x #dimension' xs) -> 
<     //   if (index < 0 || dimension <> dimension'') then BError else
<     //   if (index >= dimension) then BNone else
<     //   if index = 0 then x
<     //   else nthTuple (index-1) dimension' (BTuple dimension' xs)
<     // | _ -> BError
---
> // TODO: Implement the Record Projector
> // (* Record projector *)
> // val nthRecord : index:int -> dimension:nat -> bosqueTerm -> Tot bosqueTerm
> // let rec nthRecord index dimension y = match y with
> // | BTuple 0 SNil -> if (index < 0 || dimension <> 0) then BError else BNone
> // | BTuple dimension'' (SCons x #dimension' xs) -> 
> //   if (index < 0 || dimension <> dimension'') then BError else
> //   if (index >= dimension) then BNone else
> //   if index = 0 then x
> //   else nthTuple (index-1) dimension' (BTuple dimension' xs)
> // | _ -> BError
